// Small frozen lake MDP from OpenAI Gym.

mdp

label "start" = r=3 & c=0;
label "goal"  = r=0 & c=3;
label "trap"  = r=0 & c=0 | r=1 & c=3 | r=2 & (c=1 | c=3);

module grid
  r : [0..3] init 3;
  c : [0..3] init 0;

  [n] r<3 & c>0 & c<3 -> 1/3 : (r'=r+1) & (c'=c) +
                         1/3 : (r'=r) & (c'=c-1) + 1/3 : (r'=r) & (c'=c+1);
  [n] r<3 & c=0       -> 1/3 : (r'=r+1) & (c'=c) +
                         1/3 : (r'=r) & (c'=c) + 1/3 : (r'=r) & (c'=c+1);
  [n] r<3 & c=3       -> 1/3 : (r'=r+1) & (c'=c) +
                         1/3 : (r'=r) & (c'=c-1) + 1/3 : (r'=r) & (c'=c);
  [n] r=3 & c>0 & c<3 -> 1/3 : (r'=r) & (c'=c) +
                         1/3 : (r'=r) & (c'=c-1) + 1/3 : (r'=r) & (c'=c+1);
  [n] r=3 & c=0       -> 2/3 : (r'=r) & (c'=c) + 1/3 : (r'=r) & (c'=c+1);
  [n] r=3 & c=3       -> 2/3 : (r'=r) & (c'=c) + 1/3 : (r'=r) & (c'=c-1);

  [e] r>0 & r<3 & c<3 -> 1/3 : (r'=r) & (c'=c+1) +
                         1/3 : (r'=r+1) & (c'=c) + 1/3 : (r'=r-1) & (c'=c);
  [e] r=0 & c<3       -> 1/3 : (r'=r) & (c'=c+1) +
                         1/3 : (r'=r+1) & (c'=c) + 1/3 : (r'=r) & (c'=c);
  [e] r=3 & c<3       -> 1/3 : (r'=r) & (c'=c+1) +
                         1/3 : (r'=r) & (c'=c) + 1/3 : (r'=r-1) & (c'=c);
  [e] r>0 & r<3 & c=3 -> 1/3 : (r'=r) & (c'=c) +
                         1/3 : (r'=r+1) & (c'=c) + 1/3 : (r'=r-1) & (c'=c);
  [e] r=0 & c=3       -> 2/3 : (r'=r) & (c'=c) + 1/3 : (r'=r+1) & (c'=c);
  [e] r=3 & c=3       -> 2/3 : (r'=r) & (c'=c) + 1/3 : (r'=r-1) & (c'=c);

  [s] r>0 & c>0 & c<3 -> 1/3 : (r'=r-1) & (c'=c) +
                         1/3 : (r'=r) & (c'=c-1) + 1/3 : (r'=r) & (c'=c+1);
  [s] r>0 & c=0       -> 1/3 : (r'=r-1) & (c'=c) +
                         1/3 : (r'=r) & (c'=c) + 1/3 : (r'=r) & (c'=c+1);
  [s] r>0 & c=3       -> 1/3 : (r'=r-1) & (c'=c) +
                         1/3 : (r'=r) & (c'=c-1) + 1/3 : (r'=r) & (c'=c);
  [s] r=0 & c>0 & c<3 -> 1/3 : (r'=r) & (c'=c) +
                         1/3 : (r'=r) & (c'=c-1) + 1/3 : (r'=r) & (c'=c+1);
  [s] r=0 & c=0       -> 2/3 : (r'=r) & (c'=c) + 1/3 : (r'=r) & (c'=c+1);
  [s] r=0 & c=3       -> 2/3 : (r'=r) & (c'=c) + 1/3 : (r'=r) & (c'=c-1);

  [w] r>0 & r<3 & c>0 -> 1/3 : (r'=r) & (c'=c-1) +
                         1/3 : (r'=r+1) & (c'=c) + 1/3 : (r'=r-1) & (c'=c);
  [w] r=0 & c>0       -> 1/3 : (r'=r) & (c'=c-1) +
                         1/3 : (r'=r+1) & (c'=c) + 1/3 : (r'=r) & (c'=c);
  [w] r=3 & c>0       -> 1/3 : (r'=r) & (c'=c-1) +
                         1/3 : (r'=r) & (c'=c) + 1/3 : (r'=r-1) & (c'=c);
  [w] r>0 & r<3 & c=0 -> 1/3 : (r'=r) & (c'=c) +
                         1/3 : (r'=r+1) & (c'=c) + 1/3 : (r'=r-1) & (c'=c);
  [w] r=0 & c=0       -> 2/3 : (r'=r) & (c'=c) + 1/3 : (r'=r+1) & (c'=c);
  [w] r=3 & c=0       -> 2/3 : (r'=r) & (c'=c) + 1/3 : (r'=r-1) & (c'=c);
endmodule

rewards
  r=0 & c=3 : 1.0;
  r=0 & c=0 | r=1 & c=3 | r=2 & (c=1 | c=3) : -1.0;
endrewards
